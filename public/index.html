<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>数独 Sudoku</title>
<style>
.changelog-details {
  margin: 1em auto;
  padding: 0.8em;
  border: 1px solid #ddd;
  border-radius: 8px;
  background: #f9f9f9;
  max-width: 550px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.03);
  font-size: 1em;
}

.changelog-details summary {
  font-weight: 600;
  font-size: 1.15em;
  cursor: pointer;
  outline: none;
  padding: 0.2em 0;
  list-style: none;
}

.changelog-details ul {
  margin: 0.8em 0 0 1em;
  padding: 0;
}

.changelog-details li {
  line-height: 1.7;
  margin-bottom: 0.5em;
  word-break: break-word;
}

@media (max-width: 600px) {
  .changelog-details {
    max-width: 98vw;
    padding: 0.6em;
    font-size: 0.98em;
  }
  .changelog-details summary {
    font-size: 1em;
  }
}
  body { font-family: Arial, Helvetica, sans-serif; display:flex; flex-direction:column; align-items:center; padding:20px; background:#f6f8fa; }
  h1 { margin-bottom:5px; }
  #controls { margin:10px 0 20px; display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  select, button { padding:6px 10px; font-size:14px; }
  #board { display:grid; grid-template-columns: repeat(9, 44px); grid-auto-rows:44px; gap:0; border:3px solid #333; background:#fff; }
  .cell {
    width:44px; height:44px; box-sizing:border-box;
    display:flex; align-items:center; justify-content:center;
    border:1px solid #999; font-size:18px; position:relative;
  }
  .cell:nth-child(3n) { border-right:3px solid #333; }
  /* 3x3 block thicker horizontal borders */
  .row-break { border-bottom:3px solid #333; }
  .prefilled { background:#eee; font-weight:700; }
  input.cell-input {
    width:100%; height:100%; border:0; outline:0; text-align:center; font-size:18px;
    background:transparent; caret-color:blue;
  }
  .conflict { background: #ffdddd !important; }
  #status { margin-top:12px; min-height:24px; }
  #timer { font-weight:700; margin-left:6px; }
  #records { margin-top:14px; width:100%; max-width:540px; padding:10px; background:#fff; border:1px solid #ddd; border-radius:6px;}
  .record-row { display:flex; justify-content:space-between; padding:6px 0; border-bottom:1px dashed #eee; }
  .record-row:last-child { border-bottom:0; }
  .small { font-size:13px; color:#666; }
  @media (max-width:520px) {
    #board { grid-template-columns: repeat(9, 36px); grid-auto-rows:36px; }
    .cell { width:36px; height:36px; font-size:16px; }
  }
  body.dark {
  background: #181a1b;
  color: #eee;
}
body.dark #board { background: #222; border-color: #666; }
body.dark .cell { background: #222; border-color: #555; color: #eee; }
body.dark .cell:nth-child(3n) { border-right:3px solid #bbb; }
body.dark .row-break { border-bottom:3px solid #bbb; }
body.dark .prefilled { background: #333; color: #fff; }
body.dark .conflict { background: #5c2323 !important; }
body.dark #records { background: #222; border-color: #444; }
body.dark .changelog-details { background: #222; border-color: #444; color: #ccc; }
</style>
</head>
<body>
  <h1>数独游戏</h1>
  <div id="controls">
    难度：
    <select id="difficulty">
      <option value="easy">简单</option>
      <option value="medium" selected>中等</option>
      <option value="hard">困难</option>
      <option value="expert">专家</option>
    </select>
    <button id="newBtn">生成新题</button>
    <button id="resetBtn">重置</button>
    <button id="checkBtn">检查答案</button>
    <span id="status">用时：<span id="timer">00:00.00</span></span>
    <!-- 放在 #controls 区里 -->
    <input id="emailInput" type="email" placeholder="输入邮箱并发送登录链接" style="padding:6px 8px;">
    <button id="loginBtn">发送登录链接</button>
    <span id="userInfo" class="small" style="margin-left:8px;"></span>
    <button id="logoutBtn" style="display:none;padding:6px 8px;">登出</button>
    <button id="syncBtn" style="display:none;padding:6px 8px;">同步本地记录到云端</button>
    <button id="themeBtn" style="padding:6px 10px;">切换主题</button>
  </div>

  <div id="board" aria-label="数独棋盘"></div>

  <div id="records">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <strong>记录（本地）</strong>
      <button id="clearRecords" style="padding:4px 8px;">清除记录</button>
    </div>
    <div id="recordsList" class="small"></div>
  </div>

<script>
/*
  简单说明：
  - 生成完整解法 -> 逐一挖空（保证唯一解）来得到题目
  - 难度通过“挖空数量”控制（并在挖空过程中保证唯一解）
  - 使用 localStorage 保存每个难度的最好时间与历史
*/

/* ====== 变量与 DOM ====== */
const boardEl = document.getElementById('board');
const difficultyEl = document.getElementById('difficulty');
const newBtn = document.getElementById('newBtn');
const resetBtn = document.getElementById('resetBtn');
const checkBtn = document.getElementById('checkBtn');
const timerEl = document.getElementById('timer');
const statusEl = document.getElementById('status');
const recordsList = document.getElementById('recordsList');
const clearRecordsBtn = document.getElementById('clearRecords');
const themeBtn = document.getElementById('themeBtn');

let solution = null;      // 完整解（9x9 数组）
let puzzle = null;        // 题目（带空格的 9x9）
let givenMask = null;     // 9x9 布尔，true 表示预填（不可编辑）
let startTime = null;
let timerInterval = null;
let running = false;

/* 难度与挖空数量（目标空格数） */
const difficultyHoles = {
  easy: 36,
  medium: 46,
  hard: 52,
  expert: 58
};

/* ====== 工具：复制、创建空棋盘 ====== */
function createEmptyBoard() {
  return Array.from({length:9},()=>Array(9).fill(0));
}
function cloneBoard(b) {
  return b.map(row=>row.slice());
}

/* ====== 检查某位置放 value 是否合法（不检查0） ====== */
function isValidPlacement(board, r, c, value) {
  if (value === 0) return true;
  for (let i=0;i<9;i++) {
    if (i!==c && board[r][i] === value) return false;
    if (i!==r && board[i][c] === value) return false;
  }
  const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
  for (let i=0;i<3;i++) for (let j=0;j<3;j++){
    const rr = br+i, cc = bc+j;
    if ((rr!==r || cc!==c) && board[rr][cc] === value) return false;
  }
  return true;
}

/* ====== 完整解生成（回溯） ====== */
function shuffle(array) {
  for (let i=array.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [array[i],array[j]]=[array[j],array[i]];
  }
}
function generateFullBoard() {
  const board = createEmptyBoard();
  const nums = [1,2,3,4,5,6,7,8,9];

  function backtrack(pos=0){
    if (pos===81) return true;
    const r = Math.floor(pos/9), c = pos%9;
    // 随机顺序尝试数字
    shuffle(nums);
    for (let n of nums) {
      if (isValidPlacement(board, r, c, n)) {
        board[r][c]=n;
        if (backtrack(pos+1)) return true;
        board[r][c]=0;
      }
    }
    return false;
  }
  backtrack();
  return board;
}

/* ====== 求解器（计数解的数量，超过 limit 可提前停止） ====== */
function countSolutions(board, limit=2) {
  const b = cloneBoard(board);
  let count=0;

  function findEmpty() {
    for (let i=0;i<9;i++) for (let j=0;j<9;j++) if (b[i][j]===0) return [i,j];
    return null;
  }

  function backtrack() {
    if (count >= limit) return;
    const pos = findEmpty();
    if (!pos) { count++; return; }
    const [r,c] = pos;
    for (let n=1;n<=9;n++){
      if (isValidPlacement(b,r,c,n)){
        b[r][c]=n;
        backtrack();
        b[r][c]=0;
        if (count >= limit) return;
      }
    }
  }
  backtrack();
  return count;
}

/* ====== 挖空（确保唯一解） ====== */
function digHolesFromSolution(solBoard, holesTarget) {
  const board = cloneBoard(solBoard);
  const positions = [];
  for (let i=0;i<9;i++) for (let j=0;j<9;j++) positions.push([i,j]);
  shuffle(positions);

  let holes = 0;
  for (let idx=0; idx<positions.length && holes<holesTarget; idx++){
    const [r,c] = positions[idx];
    if (board[r][c] === 0) continue;
    const backup = board[r][c];
    board[r][c] = 0;

    // 检查是否仍然有唯一解
    const solutions = countSolutions(board, 2);
    if (solutions !== 1) {
      // 恢复，不挖
      board[r][c] = backup;
    } else {
      holes++;
    }
  }
  return board;
}

/* ====== 渲染棋盘 ====== */
function renderBoard(board, given) {
  boardEl.innerHTML = '';
  for (let r=0;r<9;r++){
    for (let c=0;c<9;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      // 添加 thicker bottom border after rows 3 and 6
      if (r===2 || r===5) cell.style.borderBottom = '3px solid #333';
      // 添加 thicker right border after columns 3 and 6
      if (c===2 || c===5) cell.style.borderRight = '3px solid #333';

      if (given[r][c]) {
        cell.classList.add('prefilled');
        cell.textContent = board[r][c] || '';
      } else {
        const input = document.createElement('input');
        input.type = 'text';
        input.inputMode = 'numeric';
        input.maxLength = 1;
        input.className = 'cell-input';
        input.dataset.r = r;
        input.dataset.c = c;
        input.value = board[r][c] ? board[r][c] : '';
        input.addEventListener('input', onCellInput);
        input.addEventListener('keydown', onCellKeyDown);
        cell.appendChild(input);
      }
      boardEl.appendChild(cell);
    }
  }
  updateConflicts();
}

/* ====== 获取当前用户填写的棋盘 ====== */
function readUserBoard() {
  const b = createEmptyBoard();
  const inputs = boardEl.querySelectorAll('input.cell-input');
  inputs.forEach(inp=>{
    const r = +inp.dataset.r, c = +inp.dataset.c;
    const v = parseInt(inp.value);
    b[r][c] = (!isNaN(v) && v>=1 && v<=9) ? v : 0;
  });
  // also include prefilled
  for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (givenMask[r][c]) b[r][c] = puzzle[r][c];
  return b;
}

/* ====== 单元格输入处理 ====== */
function onCellInput(e) {
  const input = e.target;
  // 只保留 1-9
  const raw = input.value.replace(/[^\d]/g,'');
  let v = raw.slice(0,1);
  if (v === '0') v = '';
  input.value = v;
  updateConflicts();
  checkAutoComplete();
}
function onCellKeyDown(e) {
  // 处理退格、上下左右输入便捷
  const k = e.key;
  if (k === 'ArrowLeft' || k === 'ArrowRight' || k === 'ArrowUp' || k === 'ArrowDown') {
    e.preventDefault();
    moveFocus(k, e.target);
  }
}
function moveFocus(dir, input) {
  const r = +input.dataset.r, c = +input.dataset.c;
  let nr=r, nc=c;
  if (dir==='ArrowLeft') nc = (c+8)%9;
  if (dir==='ArrowRight') nc = (c+1)%9;
  if (dir==='ArrowUp') nr = (r+8)%9;
  if (dir==='ArrowDown') nr = (r+1)%9;
  // find next editable input at (nr,nc) or move until editable
  for (let i=0;i<9;i++){
    const rr = (nr + Math.floor(i/9))%9;
    const cc = (nc + i)%9;
    const selector = `input.cell-input[data-r="${rr}"][data-c="${cc}"]`;
    const next = boardEl.querySelector(selector);
    if (next) { next.focus(); break; }
  }
}

/* ====== 冲突高亮 ====== */
function updateConflicts() {
  // 清除所有冲突样式
  const cells = boardEl.querySelectorAll('.cell');
  cells.forEach(c => c.classList.remove('conflict'));

  const b = readUserBoard();

  for (let r=0;r<9;r++) {
    for (let c=0;c<9;c++) {
      const v = b[r][c];
      if (!v) continue;
      // 检查行、列、块是否有重复
      for (let i=0;i<9;i++){
        if (i!==c && b[r][i]===v) {
          markCell(r,c); markCell(r,i);
        }
        if (i!==r && b[i][c]===v) {
          markCell(r,c); markCell(i,c);
        }
      }
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for (let i=0;i<3;i++) for (let j=0;j<3;j++){
        const rr = br+i, cc = bc+j;
        if ((rr!==r || cc!==c) && b[rr][cc] === v) {
          markCell(r,c); markCell(rr,cc);
        }
      }
    }
  }

  function markCell(r,c){
    const idx = r*9 + c;
    const el = boardEl.children[idx];
    if (el) el.classList.add('conflict');
  }
}

/* ====== 生成、重置、开始/停止计时 ====== */
function startTimer() {
  startTime = Date.now();
  timerEl.textContent = formatTime(0);
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=> {
    const elapsed = Date.now() - startTime;
    timerEl.textContent = formatTime(elapsed);
  }, 100);
  running = true;
}
function stopTimer() {
  if (timerInterval) clearInterval(timerInterval);
  running = false;
}
function formatTime(ms) {
  const totalCentis = Math.floor(ms/10);
  const centis = totalCentis % 100;
  const totalSeconds = Math.floor(totalCentis/100);
  const seconds = totalSeconds % 60;
  const minutes = Math.floor(totalSeconds/60);
  return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(centis).padStart(2,'0')}`;
}

/* ====== 生成新题 ====== */
async function generateNewPuzzle() {
  stopTimer();
  timerEl.textContent = '生成中...';
  await new Promise(r=>setTimeout(r,50)); // 让 UI 有响应
  const diff = difficultyEl.value;
  const holesTarget = difficultyHoles[diff] || 46;

  solution = generateFullBoard();
  const attemptedPuzzle = digHolesFromSolution(solution, holesTarget);
  // 若挖空失败（unique check 过于严格导致空不够），就接受当前挖到的
  puzzle = attemptedPuzzle;
  // given mask：非0为预填
  givenMask = createEmptyBoard().map((row, r)=>row.map((_,c)=>puzzle[r][c] !== 0));
  renderBoard(puzzle, givenMask);
  timerEl.textContent = '00:00.00';
  startTimer();
}

/* ====== 重置（回到题目初始状态） ====== */
function resetPuzzle() {
  stopTimer();
  if (!puzzle) return;
  renderBoard(puzzle, givenMask);
  timerEl.textContent = '00:00.00';
  startTimer();
}

/* ====== 检查答案（并在完成时记录时间） ====== */
function checkSolution() {
  if (!puzzle) { alert('请先生成题目'); return; }
  const user = readUserBoard();
  // 简单判断是否存在空
  for (let r=0;r<9;r++) for (let c=0;c<9;c++) {
    if (user[r][c] === 0) {
      alert('还有空格未填写。');
      return;
    }
  }
  // 检查是否每格合法
  for (let r=0;r<9;r++) for (let c=0;c<9;c++) {
    if (!isValidPlacement(user,r,c,user[r][c])) {
      alert('存在冲突，答案不正确。');
      updateConflicts();
      return;
    }
  }
  // 可选：和解答（solution）比对（solution 可能已存在）
  let solved = true;
  if (solution) {
    for (let r=0;r<9;r++) for (let c=0;c<9;c++) {
      if (user[r][c] !== solution[r][c]) solved = false;
    }
  } else {
    // 若没有保存 solution，则尝试求解并比较唯一性
    const b = cloneBoard(user);
    const solCount = countSolutions(b, 2);
    if (solCount !== 1) solved = false;
  }

  if (solved) {
    stopTimer();
    const elapsed = Date.now() - startTime;
    const diff = difficultyEl.value;
    saveRecord(diff, elapsed);
    alert('恭喜你，完成了！用时：' + formatTime(elapsed));
    renderRecords();
  } else {
    alert('答案与标准解不一致或不唯一。');
  }
}

/* ====== 自动完成检测（当全部填写时自动触发检查） ====== */
function checkAutoComplete() {
  const user = readUserBoard();
  for (let r=0;r<9;r++) for (let c=0;c<9;c++) {
    if (user[r][c] === 0) return;
  }
  // 若全填且无冲突，则自动检查解是否正确
  let hasConflict = !!boardEl.querySelector('.conflict');
  if (!hasConflict) {
    // 触发完成判定（但不必弹出太多重复提示）
    checkSolution();
  }
}

/* ====== 记录保存（localStorage） ====== */
const STORAGE_KEY = 'sudoku_records_v1';
function loadRecords() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return {};
    return JSON.parse(raw);
  } catch(e) { return {}; }
}
function saveRecords(obj) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
}
async function saveRecord(difficulty, ms) {
  // 原有的本地保存逻辑
  const rec = loadRecords();
  if (!rec[difficulty]) rec[difficulty] = { best: null, history: [] };
  rec[difficulty].history.push({ time: ms, at: Date.now() });
  if (!rec[difficulty].best || ms < rec[difficulty].best) {
    rec[difficulty].best = ms;
  }
  saveRecords(rec);
  
  // 如果用户已登录，上传该条记录
  // 假设你在模块脚本里有全局 supabase 实例；若不是同一作用域，你可把这段逻辑封装成函数并调用。
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (session) {
      // 插入远端 games
      await supabase.from('games').insert([{
        user_id: session.user.id,
        difficulty,
        duration_ms: ms,
        success: true
      }])
      // 更新 best_scores（简单逻辑：如果新纪录比远端最好小就 upsert）
      const { data: existing } = await supabase.from('best_scores')
        .select('best_duration_ms').eq('user_id', session.user.id).eq('difficulty', difficulty).single()
      if (!existing || ms < existing.best_duration_ms) {
        await supabase.from('best_scores').upsert({
          user_id: session.user.id,
          difficulty,
          best_duration_ms: ms,
          achieved_at: new Date().toISOString()
        }, { onConflict: ['user_id','difficulty'] })
      }
    }
  } catch (e) {
    console.warn('远端保存记录失败（可能网络或权限问题）', e)
  }
}
function clearRecords() {
  localStorage.removeItem(STORAGE_KEY);
  renderRecords();
}

/* ====== 渲染记录 ====== */
function renderRecords() {
  const rec = loadRecords();
  const diffs = ['easy','medium','hard','expert'];
  recordsList.innerHTML = diffs.map(d=>{
    const obj = rec[d];
    if (!obj) return `<div class="record-row"><div>${labelOf(d)}</div><div class="small">无记录</div></div>`;
    const best = formatTime(obj.best);
    const last = obj.history.length ? obj.history[obj.history.length-1].time : null;
    const lastStr = last ? formatTime(last) : '—';
    return `<div class="record-row"><div>${labelOf(d)} <span class="small">（最近：${lastStr}）</span></div><div>最好：${best}</div></div>`;
  }).join('');
}
function labelOf(d) {
  return d==='easy'?'简单': d==='medium'?'中等' : d==='hard'?'困难':'专家';
}

/* ====== 事件绑定 ====== */
newBtn.addEventListener('click', ()=>generateNewPuzzle());
resetBtn.addEventListener('click', ()=>resetPuzzle());
checkBtn.addEventListener('click', ()=>checkSolution());
clearRecordsBtn.addEventListener('click', ()=>{ if (confirm('确定清除所有本地记录？')) clearRecords(); });
themeBtn.addEventListener('click', () => {
  document.body.classList.toggle('dark');
  themeBtn.textContent = document.body.classList.contains('dark') ? '切换为亮色' : '切换为暗色';
});

difficultyEl.addEventListener('change', ()=> {
  // 选择难度后生成新题（也可由用户手动点击生成）
  // generateNewPuzzle();
});

/* ====== 页面初始化 ====== */
function init() {
  // render empty board (all editable)
  console.log('init() running')
  puzzle = createEmptyBoard();
  givenMask = createEmptyBoard().map(row=>row.map(()=>false));
  renderBoard(puzzle, givenMask);
  renderRecords();
  timerEl.textContent = '00:00.00';
}
init();

window.saveRecordLocal = saveRecord;

// 可选：把 supabase 实例也放到 window，供原脚本直接使用
//  window.supabase = supabase

</script>


<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

// 替换为你 Supabase 项目的 URL 和 public anon key（不要在前端放 service_role key）
const SUPABASE_URL = 'https://ywzcvxypjgazdataefbq.supabase.co'
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl3emN2eHlwamdhemRhdGFlZmJxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYzNjg0MDksImV4cCI6MjA3MTk0NDQwOX0.rRrJ1Sjat2rDu0yoIOgEHs0ZrR5hO4b6k38he57uY68'
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

// DOM 元素（你已在 HTML 中加入）
const emailInput = document.getElementById('emailInput')
const loginBtn = document.getElementById('loginBtn')
const logoutBtn = document.getElementById('logoutBtn')
const userInfo = document.getElementById('userInfo')
const syncBtn = document.getElementById('syncBtn')

// 当用户点击发送魔法链接
loginBtn.addEventListener('click', async () => {
  const email = emailInput.value.trim()
  if (!email) { alert('请输入邮箱'); return; }
  // 指定回跳到当前页面，必须先在 Supabase 控制台的 Redirect URLs 中登记
  const redirectTo = window.location.href
  const { data, error } = await supabase.auth.signInWithOtp({
    email,
    options: { emailRedirectTo: redirectTo }
  })
  if (error) {
    console.error(error)
    alert('发送失败：' + (error.message || error))
  } else {
    alert('登录邮件已发送，请查收邮箱并点击链接。')
  }
})

// 登出
logoutBtn.addEventListener('click', async () => {
  await supabase.auth.signOut()
  setLoggedOutUI()
})

// 手动触发把本地记录上传到 Supabase（若已登录）
syncBtn.addEventListener('click', async () => {
  const session = (await supabase.auth.getSession()).data.session
  if (!session) { alert('未登录'); return; }
  await syncLocalRecordsToSupabase(session.user.id)
  alert('同步完成（如果有新记录）。')
})

// 页面加载时：检查当前是否已登录并设置 UI；并监听 auth 状态变化
async function initAuth() {
  // 有时用户点击魔法链接回到页面后需要处理 URL 中的参数以建立 session：
  // supabase-js 会在某些版本自动处理，但强烈建议调用 getSessionFromUrl() 如果 URL 中有 magic link token
  try {
    // 如果 URL 含有 `access_token` 或 magic link 参数，可以调用：
    // await supabase.auth.getSessionFromUrl({ storeSession: true })
    // 但为兼容不同版本，也使用下面的 getSession() 来读取当前 session
  } catch(e) {
    // ignore
  }

  // 读取当前 session
  const { data: { session } } = await supabase.auth.getSession()
  if (session) {
    setLoggedInUI(session.user)
    // 登录后自动尝试同步本地记录
    await syncLocalRecordsToSupabase(session.user.id)
  } else {
    setLoggedOutUI()
  }

  // 监听登录/登出事件（页面内实时更新 UI）
  supabase.auth.onAuthStateChange((_event, state) => {
    if (state?.user) setLoggedInUI(state.user)
    else setLoggedOutUI()
  })
}
initAuth()

function setLoggedInUI(user) {
  userInfo.textContent = user.email || user.id
  loginBtn.style.display = 'none'
  emailInput.style.display = 'none'
  logoutBtn.style.display = ''
  syncBtn.style.display = ''
}
function setLoggedOutUI() {
  userInfo.textContent = ''
  loginBtn.style.display = ''
  emailInput.style.display = ''
  logoutBtn.style.display = 'none'
  syncBtn.style.display = 'none'
}

/* ====== 将本地 localStorage 里的记录上报到 Supabase ======
   假设你本地使用的 STORAGE_KEY 与页面相同：'sudoku_records_v1'
   我们要把历史每条作为一行插入到远端的 `games` 表里，
   并维护 `best_scores` 表或在插入后判断并更新最佳成绩。
*/
const STORAGE_KEY = 'sudoku_records_v1'

async function syncLocalRecordsToSupabase(userId) {
  const raw = localStorage.getItem(STORAGE_KEY)
  if (!raw) return
  let rec
  try { rec = JSON.parse(raw) } catch(e) { return }
  const rowsToInsert = []
  for (const diff of ['easy','medium','hard','expert']) {
    const obj = rec[diff]
    if (!obj || !obj.history || obj.history.length === 0) continue
    // 把每条历史上传，字段名与下方 SQL 表描述要对应
    for (const h of obj.history) {
      rowsToInsert.push({
        user_id: userId,
        difficulty: diff,
        duration_ms: h.time,
        created_at: new Date(h.at).toISOString(),
        success: true
      })
    }
  }
  if (rowsToInsert.length === 0) return

  // 批量插入
  const { error: insertError } = await supabase.from('games').insert(rowsToInsert)
  if (insertError) {
    console.error('上传记录失败', insertError)
    return
  }

  // 可选：更新 best_scores（你也可以在 DB 侧用触发器/函数来维护）
  for (const diff of ['easy','medium','hard','expert']) {
    const obj = rec[diff]
    if (!obj || !obj.history || obj.history.length === 0) continue
    const localBest = obj.best
    if (!localBest) continue
    // 读取远端当前 best
    const { data: existing, error: selErr } = await supabase
      .from('best_scores')
      .select('best_duration_ms')
      .eq('user_id', userId)
      .eq('difficulty', diff)
      .single()
    if (selErr && selErr.code !== 'PGRST116') {
      console.warn('读取远端 best 失败', selErr)
      continue
    }
    let shouldUpsert = false
    if (!existing) shouldUpsert = true
    else if (localBest < existing.best_duration_ms) shouldUpsert = true

    if (shouldUpsert) {
      const { error: upErr } = await supabase.from('best_scores').upsert({
        user_id: userId,
        difficulty: diff,
        best_duration_ms: localBest,
        achieved_at: new Date().toISOString()
      }, { onConflict: ['user_id','difficulty'] })
      if (upErr) console.warn('更新 best 失败', upErr)
    }
  }

  // 如果需要：上传成功后清本地或标记为已同步。这里我们不自动清，避免用户误删数据。
  // localStorage.removeItem(STORAGE_KEY)
}

</script>
<details class="changelog-details">
  <summary>Changelog（更新日志）</summary>
  <ul>
    <li><strong>2025-08-28 21:41</strong>：Version 0.21 利用resend发邮件，用户登录功能，开发完成</li>
    <li><strong>2025-08-28</strong>：Version 0.21 增加用户登录功能，开发中</li>
    <li><strong>2025-08-28</strong>：Version 0.1 游戏成绩用浏览器本地存储</li>
  </ul>
</details>
</body>
</html>