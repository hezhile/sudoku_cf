<!doctype html>
<html lang="zh-CN">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-H0KWSWN39R"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-H0KWSWN39R');
</script>  
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>数独 Sudoku - Free Sudoku Puzzles Online</title>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<style>
.changelog-details {
  margin: 1em auto;
  padding: 0.8em;
  border: 1px solid #ddd;
  border-radius: 8px;
  background: #f9f9f9;
  max-width: 540px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.03);
  font-size: 1em;
}

.changelog-details summary {
  font-weight: 600;
  font-size: 1.15em;
  cursor: pointer;
  outline: none;
  padding: 0.2em 0;
  list-style: none;
}

.changelog-details ul {
  margin: 0.8em 0 0 1em;
  padding: 0;
}

.changelog-details li {
  line-height: 1.7;
  margin-bottom: 0.5em;
  word-break: break-word;
}

@media (max-width: 600px) {
  .changelog-details {
    max-width: 98vw;
    padding: 0.6em;
    font-size: 0.98em;
  }
  .changelog-details summary {
    font-size: 0.85em;
  }
}
  :root {
    /* 浅色主题 */
    --bg-primary: #f6f8fa;
    --bg-board: #ffffff;
    --bg-prefilled: #eeeeee;
    --bg-records: #ffffff;
    --bg-button: #f0f0f0;
    --text-primary: #000000;
    --text-secondary: #666666;
    --border-normal: #999999;
    --border-thick: #333333;
    --border-records: #dddddd;
    --border-dashed: #eeeeee;
    --conflict-bg: #ffdddd;
    --caret-color: #0066cc;
  }

  @media (prefers-color-scheme: dark) {
    :root {
      /* 暗色主题 */
      --bg-primary: #1a1a1a;
      --bg-board: #2d2d2d;
      --bg-prefilled: #3a3a3a;
      --bg-records: #252525;
      --bg-button: #404040;
      --text-primary: #e0e0e0;
      --text-secondary: #a0a0a0;
      --border-normal: #555555;
      --border-thick: #777777;
      --border-records: #555555;
      --border-dashed: #444444;
      --conflict-bg: #8b3a3a;
      --caret-color: #4a9eff;
    }
  }

  body { 
    font-family: Arial, Helvetica, sans-serif; 
    display:flex; 
    flex-direction:column; 
    align-items:center; 
    padding:20px; 
    background:var(--bg-primary); 
    color:var(--text-primary);
    position: relative;
  }
  h1 { 
    position: relative;
    font-size: 24px;
    margin: 10px 0;
    text-align: left;
    color:var(--text-primary);
  }
  
  /* 登录区域样式 */
  #loginArea {
    position: relative;
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: flex-end;
    margin: 10px 0;
  }
  
  /* 计时器区域样式 */
  #timerArea {
    text-align: center;
    margin: 15px 0;
    font-size: 20px;
    color: var(--text-primary);
  }
  
  /* 统一控件高度 */
  select, button {
    height: 32px;
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  
  /* 记录区域按钮样式 */
  #recordButtons {
    display: flex;
    gap: 8px;
  }
  
  /* 登出链接样式 */
  .logout-link {
    background: none !important;
    border: none !important;
    color: var(--text-primary) !important;
    text-decoration: underline;
    cursor: pointer;
    padding: 0 !important;
    font-size: 13px;
    height: auto !important;
    display: inline ;
  }
  
  .logout-link:hover {
    background: none !important;
    color: var(--caret-color) !important;
  }
  
  /* 暗红色按钮样式 */
  .danger-button {
    background: var(--bg-button) !important;
    color: #d32f2f !important;
    border: 1px solid var(--border-normal) !important;
  }
  
  .danger-button:hover {
    background: var(--bg-prefilled) !important;
    color: #b71c1c !important;
  }
  
  /* 手机端优化 */
  @media (max-width: 768px) {
    #loginArea {
      max-width: 200px;
    }
    
    h1 {
      margin: 8px 0;
    }
    
    .logout-link {
      font-size: 14px;
    }
  }
  #controls { 
    margin:10px 0; 
    display:flex; 
    gap:10px; 
    align-items:center; 
    flex-wrap:wrap; 
    color:var(--text-primary);
  }
  select, button { 
    padding:6px 10px; 
    font-size:14px; 
    background:var(--bg-button);
    color:var(--text-primary);
    border:1px solid var(--border-normal);
    border-radius:4px;
  }
  select:hover, button:hover {
    background:var(--bg-prefilled);
  }
  #board { 
    display:grid; 
    grid-template-columns: repeat(9, 44px); 
    grid-auto-rows:44px; 
    gap:0; 
    border:3px solid var(--border-thick); 
    background:var(--bg-board); 
  }
  .cell {
    width:44px; 
    height:44px; 
    box-sizing:border-box;
    display:flex; 
    align-items:center; 
    justify-content:center;
    border:1px solid var(--border-normal); 
    font-size:18px; 
    position:relative;
    color:var(--text-primary);
  }
  .cell:nth-child(3n) { border-right:3px solid var(--border-thick); }
  /* .cell:nth-child(n+19):nth-child(-n+27), .cell:nth-child(n+46):nth-child(-n+54) { */
    /* just to avoid CSS complexity for horizontal thicker lines we set via :nth-child below */
  /* }
  /* 3x3 block thicker horizontal borders */
  .row-break { border-bottom:3px solid var(--border-thick); }
  .prefilled { 
    background:var(--bg-prefilled); 
    font-weight:700; 
    color:var(--text-primary);
  }
  input.cell-input {
    width:100%; 
    height:100%; 
    border:0; 
    outline:0; 
    text-align:center; 
    font-size:18px;
    background:transparent; 
    caret-color:var(--caret-color);
    color:var(--text-primary);
  }
  .conflict { 
    background: var(--conflict-bg) !important; 
    color:var(--text-primary);
  }
  /* 移除不再使用的status样式 */
  /* #status { 
    margin-top:12px; 
    min-height:24px; 
    color:var(--text-primary);
  } */
  #timer { 
    font-weight:700; 
    margin-left:6px; 
    color:var(--text-primary);
  }
  #records { 
    margin-top:14px; 
    width:100%; 
    max-width:540px; 
    padding:10px; 
    background:var(--bg-records); 
    border:1px solid var(--border-records); 
    border-radius:6px;
    color:var(--text-primary);
  }
  .record-row { 
    display:flex; 
    justify-content:space-between; 
    padding:6px 0; 
    border-bottom:1px dashed var(--border-dashed); 
    color:var(--text-primary);
  }
  .record-row:last-child { border-bottom:0; }
  .small { 
    font-size:13px; 
    color:var(--text-secondary); 
  }
  .changelog-details {
    margin: 1em auto;
    padding: 0.8em;
    border: 1px solid var(--border-records);
    border-radius: 8px;
    background: var(--bg-records);
    max-width: 540px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.03);
    font-size: 1em;
    color:var(--text-primary);
  }

  .changelog-details summary {
    font-weight: 600;
    font-size: 0.9em;
    cursor: pointer;
    outline: none;
    padding: 0.2em 0;
    list-style: none;
    color:var(--text-primary);
    text-align: left;
    padding-left: 20px;
    position: relative;
  }

  .changelog-details summary::before {
    content: ">";
    position: absolute;
    left: 0;
    top: 0.2em;
  }

  .changelog-details[open] summary::before {
    content: "▼";
  }

  .changelog-details ul {
    margin: 0.8em 0 0 1em;
    padding: 0;
    color:var(--text-primary);
  }

  .changelog-details li {
    line-height: 1.7;
    margin-bottom: 0.5em;
    word-break: break-word;
    color:var(--text-primary);
  }
  @media (max-width:520px) {
    #board { grid-template-columns: repeat(9, 36px); grid-auto-rows:36px; }
    .cell { width:36px; height:36px; font-size:16px; }
  }
</style>
</head>
<body>
  <h1>数独游戏</h1>
  <!-- 登录区域 - 右上角 -->
  <div id="loginArea">
    <input id="emailInput" type="email" placeholder="输入邮箱并发送登录链接" style="padding:6px 8px;background:var(--bg-button);color:var(--text-primary);border:1px solid var(--border-normal);border-radius:4px;height:36px;box-sizing:border-box;">
    <button id="loginBtn">发送登录链接</button>
    <span id="userInfo" class="small" style="margin-left:8px;"></span>
    <button id="logoutBtn" class="logout-link" style="display:none;">登出</button>
  </div>

  
  
  <!-- 控制区域 -->
  <div id="controls">
      <select id="difficulty">
      <option value="easy">简单</option>
      <option value="medium" selected>中等难度</option>
      <option value="hard">困难</option>
      <option value="expert">专家</option>
    </select>
    <button id="newBtn">生成新题</button>
    <button id="resetBtn">重置</button>
    <!-- <button id="checkBtn">检查答案</button> -->
  </div>
  
  <!-- 计时器区域 - 单独居中 -->
  <div id="timerArea">
    用时：<span id="timer">00:00.00</span>
  </div>

  <div id="board" aria-label="数独棋盘"></div>

  <div id="records">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <strong>记录（本地）</strong>
      <div id="recordButtons">
        <button id="syncBtn" style="display:none;padding:4px 8px;">上传到云端</button>
        <button id="clearRecords" class="danger-button" style="padding:4px 8px;">清除</button>
      </div>
    </div>
    <div id="recordsList" class="small"></div>
  </div>

<script>
/*
  简单说明：
  - 生成完整解法 -> 逐一挖空（保证唯一解）来得到题目
  - 难度通过“挖空数量”控制（并在挖空过程中保证唯一解）
  - 使用 localStorage 保存每个难度的最好时间与历史
*/

/* ====== 变量与 DOM ====== */
const boardEl = document.getElementById('board');
const difficultyEl = document.getElementById('difficulty');
const newBtn = document.getElementById('newBtn');
const resetBtn = document.getElementById('resetBtn');
// const checkBtn = document.getElementById('checkBtn');
const timerEl = document.getElementById('timer');
const statusEl = document.getElementById('status');
const recordsList = document.getElementById('recordsList');
const clearRecordsBtn = document.getElementById('clearRecords');

let solution = null;      // 完整解（9x9 数组）
let puzzle = null;        // 题目（带空格的 9x9）
let givenMask = null;     // 9x9 布尔，true 表示预填（不可编辑）
let startTime = null;
let timerInterval = null;
let running = false;

/* 难度与挖空数量（目标空格数） */
const difficultyHoles = {
  easy: 36,
  medium: 46,
  hard: 52,
  expert: 58
};

/* ====== 工具：复制、创建空棋盘 ====== */
function createEmptyBoard() {
  return Array.from({length:9},()=>Array(9).fill(0));
}
function cloneBoard(b) {
  return b.map(row=>row.slice());
}

/* ====== 检查某位置放 value 是否合法（不检查0） ====== */
function isValidPlacement(board, r, c, value) {
  if (value === 0) return true;
  for (let i=0;i<9;i++) {
    if (i!==c && board[r][i] === value) return false;
    if (i!==r && board[i][c] === value) return false;
  }
  const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
  for (let i=0;i<3;i++) for (let j=0;j<3;j++){
    const rr = br+i, cc = bc+j;
    if ((rr!==r || cc!==c) && board[rr][cc] === value) return false;
  }
  return true;
}

/* ====== 完整解生成（回溯） ====== */
function shuffle(array) {
  for (let i=array.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [array[i],array[j]]=[array[j],array[i]];
  }
}
function generateFullBoard() {
  const board = createEmptyBoard();
  const nums = [1,2,3,4,5,6,7,8,9];

  function backtrack(pos=0){
    if (pos===81) return true;
    const r = Math.floor(pos/9), c = pos%9;
    // 随机顺序尝试数字
    shuffle(nums);
    for (let n of nums) {
      if (isValidPlacement(board, r, c, n)) {
        board[r][c]=n;
        if (backtrack(pos+1)) return true;
        board[r][c]=0;
      }
    }
    return false;
  }
  backtrack();
  return board;
}

/* ====== 求解器（计数解的数量，超过 limit 可提前停止） ====== */
function countSolutions(board, limit=2) {
  const b = cloneBoard(board);
  let count=0;

  function findEmpty() {
    for (let i=0;i<9;i++) for (let j=0;j<9;j++) if (b[i][j]===0) return [i,j];
    return null;
  }

  function backtrack() {
    if (count >= limit) return;
    const pos = findEmpty();
    if (!pos) { count++; return; }
    const [r,c] = pos;
    for (let n=1;n<=9;n++){
      if (isValidPlacement(b,r,c,n)){
        b[r][c]=n;
        backtrack();
        b[r][c]=0;
        if (count >= limit) return;
      }
    }
  }
  backtrack();
  return count;
}

/* ====== 挖空（确保唯一解） ====== */
function digHolesFromSolution(solBoard, holesTarget) {
  const board = cloneBoard(solBoard);
  const positions = [];
  for (let i=0;i<9;i++) for (let j=0;j<9;j++) positions.push([i,j]);
  shuffle(positions);

  let holes = 0;
  for (let idx=0; idx<positions.length && holes<holesTarget; idx++){
    const [r,c] = positions[idx];
    if (board[r][c] === 0) continue;
    const backup = board[r][c];
    board[r][c] = 0;

    // 检查是否仍然有唯一解
    const solutions = countSolutions(board, 2);
    if (solutions !== 1) {
      // 恢复，不挖
      board[r][c] = backup;
    } else {
      holes++;
    }
  }
  return board;
}

/* ====== 渲染棋盘 ====== */
function renderBoard(board, given) {
  boardEl.innerHTML = '';
  for (let r=0;r<9;r++){
    for (let c=0;c<9;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      // 添加 thicker bottom border after rows 3 and 6
      if (r===2 || r===5) cell.style.borderBottom = '3px solid var(--border-thick)';
      // 添加 thicker right border after columns 3 and 6
      if (c===2 || c===5) cell.style.borderRight = '3px solid var(--border-thick)';

      if (given[r][c]) {
        cell.classList.add('prefilled');
        cell.textContent = board[r][c] || '';
      } else {
        const input = document.createElement('input');
        input.type = 'text';
        input.inputMode = 'numeric';
        input.maxLength = 1;
        input.className = 'cell-input';
        input.dataset.r = r;
        input.dataset.c = c;
        input.value = board[r][c] ? board[r][c] : '';
        input.addEventListener('input', onCellInput);
        input.addEventListener('keydown', onCellKeyDown);
        cell.appendChild(input);
      }
      boardEl.appendChild(cell);
    }
  }
  updateConflicts();
}

/* ====== 获取当前用户填写的棋盘 ====== */
function readUserBoard() {
  const b = createEmptyBoard();
  const inputs = boardEl.querySelectorAll('input.cell-input');
  inputs.forEach(inp=>{
    const r = +inp.dataset.r, c = +inp.dataset.c;
    const v = parseInt(inp.value);
    b[r][c] = (!isNaN(v) && v>=1 && v<=9) ? v : 0;
  });
  // also include prefilled
  for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (givenMask[r][c]) b[r][c] = puzzle[r][c];
  return b;
}

/* ====== 单元格输入处理 ====== */
function onCellInput(e) {
  const input = e.target;
  // 只保留 1-9
  const raw = input.value.replace(/[^\d]/g,'');
  let v = raw.slice(0,1);
  if (v === '0') v = '';
  input.value = v;
  updateConflicts();
  checkAutoComplete();
}
function onCellKeyDown(e) {
  // 处理退格、上下左右输入便捷
  const k = e.key;
  if (k === 'ArrowLeft' || k === 'ArrowRight' || k === 'ArrowUp' || k === 'ArrowDown') {
    e.preventDefault();
    moveFocus(k, e.target);
  }
}
function moveFocus(dir, input) {
  const r = +input.dataset.r, c = +input.dataset.c;
  let nr=r, nc=c;
  if (dir==='ArrowLeft') nc = (c+8)%9;
  if (dir==='ArrowRight') nc = (c+1)%9;
  if (dir==='ArrowUp') nr = (r+8)%9;
  if (dir==='ArrowDown') nr = (r+1)%9;
  // find next editable input at (nr,nc) or move until editable
  for (let i=0;i<9;i++){
    const rr = (nr + Math.floor(i/9))%9;
    const cc = (nc + i)%9;
    const selector = `input.cell-input[data-r="${rr}"][data-c="${cc}"]`;
    const next = boardEl.querySelector(selector);
    if (next) { next.focus(); break; }
  }
}

/* ====== 冲突高亮 ====== */
function updateConflicts() {
  // 清除所有冲突样式
  const cells = boardEl.querySelectorAll('.cell');
  cells.forEach(c => c.classList.remove('conflict'));

  const b = readUserBoard();

  for (let r=0;r<9;r++) {
    for (let c=0;c<9;c++) {
      const v = b[r][c];
      if (!v) continue;
      // 检查行、列、块是否有重复
      for (let i=0;i<9;i++){
        if (i!==c && b[r][i]===v) {
          markCell(r,c); markCell(r,i);
        }
        if (i!==r && b[i][c]===v) {
          markCell(r,c); markCell(i,c);
        }
      }
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for (let i=0;i<3;i++) for (let j=0;j<3;j++){
        const rr = br+i, cc = bc+j;
        if ((rr!==r || cc!==c) && b[rr][cc] === v) {
          markCell(r,c); markCell(rr,cc);
        }
      }
    }
  }

  function markCell(r,c){
    const idx = r*9 + c;
    const el = boardEl.children[idx];
    if (el) el.classList.add('conflict');
  }
}

/* ====== 生成、重置、开始/停止计时 ====== */
function startTimer() {
  startTime = Date.now();
  timerEl.textContent = formatTime(0);
  if (timerInterval) clearInterval(timerInterval);
  timerInterval = setInterval(()=> {
    const elapsed = Date.now() - startTime;
    timerEl.textContent = formatTime(elapsed);
  }, 100);
  running = true;
}
function stopTimer() {
  if (timerInterval) clearInterval(timerInterval);
  running = false;
}
function formatTime(ms) {
  const totalCentis = Math.floor(ms/10);
  const centis = totalCentis % 100;
  const totalSeconds = Math.floor(totalCentis/100);
  const seconds = totalSeconds % 60;
  const minutes = Math.floor(totalSeconds/60);
  return `${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}.${String(centis).padStart(2,'0')}`;
}

/* ====== 生成新题 ====== */
async function generateNewPuzzle() {
  stopTimer();
  timerEl.textContent = '生成中...';
  await new Promise(r=>setTimeout(r,50)); // 让 UI 有响应
  const diff = difficultyEl.value;
  const holesTarget = difficultyHoles[diff] || 46;

  solution = generateFullBoard();
  const attemptedPuzzle = digHolesFromSolution(solution, holesTarget);
  // 若挖空失败（unique check 过于严格导致空不够），就接受当前挖到的
  puzzle = attemptedPuzzle;
  // given mask：非0为预填
  givenMask = createEmptyBoard().map((row, r)=>row.map((_,c)=>puzzle[r][c] !== 0));
  renderBoard(puzzle, givenMask);
  timerEl.textContent = '00:00.00';
  startTimer();
}

/* ====== 重置（回到题目初始状态） ====== */
function resetPuzzle() {
  stopTimer();
  if (!puzzle) return;
  renderBoard(puzzle, givenMask);
  timerEl.textContent = '00:00.00';
  startTimer();
}

/* ====== 检查答案（并在完成时记录时间） ====== */
function checkSolution() {
  if (!puzzle) { alert('请先生成题目'); return; }
  const user = readUserBoard();
  // 简单判断是否存在空
  for (let r=0;r<9;r++) for (let c=0;c<9;c++) {
    if (user[r][c] === 0) {
      alert('还有空格未填写。');
      return;
    }
  }
  // 检查是否每格合法
  for (let r=0;r<9;r++) for (let c=0;c<9;c++) {
    if (!isValidPlacement(user,r,c,user[r][c])) {
      alert('存在冲突，答案不正确。');
      updateConflicts();
      return;
    }
  }
  // 可选：和解答（solution）比对（solution 可能已存在）
  let solved = true;
  if (solution) {
    for (let r=0;r<9;r++) for (let c=0;c<9;c++) {
      if (user[r][c] !== solution[r][c]) solved = false;
    }
  } else {
    // 若没有保存 solution，则尝试求解并比较唯一性
    const b = cloneBoard(user);
    const solCount = countSolutions(b, 2);
    if (solCount !== 1) solved = false;
  }

  if (solved) {
    stopTimer();
    const elapsed = Date.now() - startTime;
    const diff = difficultyEl.value;
    saveRecord(diff, elapsed);
    alert('恭喜你，完成了！用时：' + formatTime(elapsed));
    renderRecords();
  } else {
    alert('答案与标准解不一致或不唯一。');
  }
}

/* ====== 自动完成检测（当全部填写时自动触发检查） ====== */
function checkAutoComplete() {
  const user = readUserBoard();
  for (let r=0;r<9;r++) for (let c=0;c<9;c++) {
    if (user[r][c] === 0) return;
  }
  // 若全填且无冲突，则自动检查解是否正确
  let hasConflict = !!boardEl.querySelector('.conflict');
  if (!hasConflict) {
    // 触发完成判定（但不必弹出太多重复提示）
    checkSolution();
  }
}

/* ====== 记录保存（localStorage） ====== */
const STORAGE_KEY = 'sudoku_records_v1';
function loadRecords() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return {};
    return JSON.parse(raw);
  } catch(e) { return {}; }
}
function saveRecords(obj) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
}
async function saveRecord(difficulty, ms) {
  // 原有的本地保存逻辑
  const rec = loadRecords();
  if (!rec[difficulty]) rec[difficulty] = { best: null, history: [] };
  
  // 添加新记录，默认未同步
  const newRecord = { time: ms, at: Date.now(), synced: false };
  rec[difficulty].history.push(newRecord);
  
  if (!rec[difficulty].best || ms < rec[difficulty].best) {
    rec[difficulty].best = ms;
  }
  saveRecords(rec);
  
  // 如果用户已登录，立即上传并标记为已同步
  try {
    const { data: { session } } = await supabase.auth.getSession();
    if (session) {
      await uploadSingleRecord(session.user.id, difficulty, newRecord);
      // 更新 best_scores
      const { data: existing } = await supabase.from('best_scores')
        .select('best_duration_ms').eq('user_id', session.user.id).eq('difficulty', difficulty).single()
      if (!existing || ms < existing.best_duration_ms) {
        await supabase.from('best_scores').upsert({
          user_id: session.user.id,
          difficulty,
          best_duration_ms: ms,
          achieved_at: new Date().toISOString()
        }, { onConflict: ['user_id','difficulty'] })
      }
      
      // 标记为已同步并保存
      newRecord.synced = true;
      saveRecords(rec);
    }
  } catch (e) {
    console.warn('远端保存记录失败（可能网络或权限问题）', e)
  }
}
function clearRecords() {
  localStorage.removeItem(STORAGE_KEY);
  renderRecords();
}

/* ====== 渲染记录 ====== */
function renderRecords() {
  const rec = loadRecords();
  const diffs = ['easy','medium','hard','expert'];
  recordsList.innerHTML = diffs.map(d=>{
    const obj = rec[d];
    if (!obj) return `<div class="record-row"><div>${labelOf(d)}</div><div class="small">无记录</div></div>`;
    const best = formatTime(obj.best);
    const last = obj.history.length ? obj.history[obj.history.length-1].time : null;
    const lastStr = last ? formatTime(last) : '—';
    return `<div class="record-row"><div>${labelOf(d)} <span class="small">（最近：${lastStr}）</span></div><div>最好：${best}</div></div>`;
  }).join('');
}
function labelOf(d) {
  return d==='easy'?'简单': d==='medium'?'中等' : d==='hard'?'困难':'专家';
}

/* ====== 事件绑定 ====== */
newBtn.addEventListener('click', ()=>generateNewPuzzle());
resetBtn.addEventListener('click', ()=>resetPuzzle());
// checkBtn.addEventListener('click', ()=>checkSolution());
clearRecordsBtn.addEventListener('click', ()=>{ if (confirm('确定清除所有本地记录？')) clearRecords(); });

difficultyEl.addEventListener('change', ()=> {
  // 选择难度后生成新题（也可由用户手动点击生成）
  // generateNewPuzzle();
});

/* ====== 页面初始化 ====== */
function init() {
  // render empty board (all editable)
  console.log('init() running')
  puzzle = createEmptyBoard();
  givenMask = createEmptyBoard().map(row=>row.map(()=>false));
  renderBoard(puzzle, givenMask);
  renderRecords();
  timerEl.textContent = '00:00.00';
}
init();

window.saveRecordLocal = saveRecord;
window.saveRecords = saveRecords;

// 可选：把 supabase 实例也放到 window，供原脚本直接使用
//  window.supabase = supabase

</script>


<script type="module">
import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

// 替换为你 Supabase 项目的 URL 和 public anon key（不要在前端放 service_role key）
const SUPABASE_URL = 'https://ywzcvxypjgazdataefbq.supabase.co'
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inl3emN2eHlwamdhemRhdGFlZmJxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTYzNjg0MDksImV4cCI6MjA3MTk0NDQwOX0.rRrJ1Sjat2rDu0yoIOgEHs0ZrR5hO4b6k38he57uY68'
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

// DOM 元素（你已在 HTML 中加入）
const emailInput = document.getElementById('emailInput')
const loginBtn = document.getElementById('loginBtn')
const logoutBtn = document.getElementById('logoutBtn')
const userInfo = document.getElementById('userInfo')
const syncBtn = document.getElementById('syncBtn')

// 当用户点击发送魔法链接
loginBtn.addEventListener('click', async () => {
  const email = emailInput.value.trim()
  if (!email) { alert('请输入邮箱'); return; }
  // 指定回跳到当前页面，必须先在 Supabase 控制台的 Redirect URLs 中登记
  const redirectTo = window.location.href
  const { data, error } = await supabase.auth.signInWithOtp({
    email,
    options: { emailRedirectTo: redirectTo }
  })
  if (error) {
    console.error(error)
    alert('发送失败：' + (error.message || error))
  } else {
    alert('登录邮件已发送，请查收邮箱并点击链接。')
  }
})

// 登出
logoutBtn.addEventListener('click', async () => {
  await supabase.auth.signOut()
  setLoggedOutUI()
})

// 手动触发把本地记录上传到 Supabase（若已登录）
syncBtn.addEventListener('click', async () => {
  const session = (await supabase.auth.getSession()).data.session
  if (!session) { alert('未登录'); return; }
  await syncLocalRecordsToSupabase(session.user.id)
  alert('同步完成（如果有新记录）。')
})

// 页面加载时：检查当前是否已登录并设置 UI；并监听 auth 状态变化
async function initAuth() {
  // 有时用户点击魔法链接回到页面后需要处理 URL 中的参数以建立 session：
  // supabase-js 会在某些版本自动处理，但强烈建议调用 getSessionFromUrl() 如果 URL 中有 magic link token
  try {
    // 如果 URL 含有 `access_token` 或 magic link 参数，可以调用：
    // await supabase.auth.getSessionFromUrl({ storeSession: true })
    // 但为兼容不同版本，也使用下面的 getSession() 来读取当前 session
  } catch(e) {
    // ignore
  }

  // 读取当前 session
  const { data: { session } } = await supabase.auth.getSession()
  if (session) {
    setLoggedInUI(session.user)
    // 登录后自动尝试同步本地记录
    await syncLocalRecordsToSupabase(session.user.id)
  } else {
    setLoggedOutUI()
  }

  // 监听登录/登出事件（页面内实时更新 UI）
  supabase.auth.onAuthStateChange((_event, state) => {
    if (state?.user) setLoggedInUI(state.user)
    else setLoggedOutUI()
  })
}
initAuth()

function setLoggedInUI(user) {
  userInfo.textContent = user.email || user.id
  loginBtn.style.display = 'none'
  emailInput.style.display = 'none'
  logoutBtn.style.display = 'inline-block'
  syncBtn.style.display = 'inline-block'
}
function setLoggedOutUI() {
  userInfo.textContent = ''
  loginBtn.style.display = 'inline-block'
  emailInput.style.display = 'inline-block'
  logoutBtn.style.display = 'none'
  syncBtn.style.display = 'none'
}

/* ====== 上传单条记录到 Supabase ====== */
async function uploadSingleRecord(userId, difficulty, record) {
  return await supabase.from('games').insert([{
    user_id: userId,
    difficulty: difficulty,
    duration_ms: record.time,
    created_at: new Date(record.at).toISOString(),
    success: true
  }])
}

/* ====== 将本地 localStorage 里的记录上报到 Supabase ======
   假设你本地使用的 STORAGE_KEY 与页面相同：'sudoku_records_v1'
   我们要把历史每条作为一行插入到远端的 `games` 表里，
   并维护 `best_scores` 表或在插入后判断并更新最佳成绩。
*/
// const STORAGE_KEY = 'sudoku_records_v1' // Declared in the global scope above

async function syncLocalRecordsToSupabase(userId) {
  const raw = localStorage.getItem(STORAGE_KEY)
  if (!raw) return
  let rec
  try { rec = JSON.parse(raw) } catch(e) { return }
  
  const rowsToInsert = []
  let hasUnsynced = false
  
  // 只上传未同步的记录
  for (const diff of ['easy','medium','hard','expert']) {
    const obj = rec[diff]
    if (!obj || !obj.history || obj.history.length === 0) continue
    
    for (const h of obj.history) {
      // 只处理未同步的记录
      if (!h.synced) {
        rowsToInsert.push({
          user_id: userId,
          difficulty: diff,
          duration_ms: h.time,
          created_at: new Date(h.at).toISOString(),
          success: true
        })
        hasUnsynced = true
      }
    }
  }
  
  if (rowsToInsert.length === 0) {
    console.log('没有需要同步的记录')
    return
  }

  // 批量插入未同步的记录
  const { error: insertError } = await supabase.from('games').insert(rowsToInsert)
  if (insertError) {
    console.error('上传记录失败', insertError)
    return
  }

  // 标记所有记录为已同步
  for (const diff of ['easy','medium','hard','expert']) {
    const obj = rec[diff]
    if (!obj || !obj.history) continue
    obj.history.forEach(h => {
      if (!h.synced) {
        h.synced = true
      }
    })
  }
  
  // 保存更新后的同步状态
  // 调用全局作用域中的 saveRecords 函数
  window.saveRecords(rec)
  
  // 更新 best_scores
  for (const diff of ['easy','medium','hard','expert']) {
    const obj = rec[diff]
    if (!obj || !obj.history || obj.history.length === 0) continue
    const localBest = obj.best
    if (!localBest) continue
    
    // 读取远端当前 best
    const { data: existing, error: selErr } = await supabase
      .from('best_scores')
      .select('best_duration_ms')
      .eq('user_id', userId)
      .eq('difficulty', diff)
      .single()
    if (selErr && selErr.code !== 'PGRST116') {
      console.warn('读取远端 best 失败', selErr)
      continue
    }
    let shouldUpsert = false
    if (!existing) shouldUpsert = true
    else if (localBest < existing.best_duration_ms) shouldUpsert = true

    if (shouldUpsert) {
      const { error: upErr } = await supabase.from('best_scores').upsert({
        user_id: userId,
        difficulty: diff,
        best_duration_ms: localBest,
        achieved_at: new Date().toISOString()
      }, { onConflict: ['user_id','difficulty'] })
      if (upErr) console.warn('更新 best 失败', upErr)
    }
  }

  console.log(`成功同步 ${rowsToInsert.length} 条记录`)
}

</script>
<details class="changelog-details">
  <summary>Changelog（更新日志）</summary>
  <ul>
    <li><strong>2025-09-11 </strong>：Version 0.22 增加夜间主题，优化UI</li>
    <li><strong>2025-08-28 21:41</strong>：Version 0.21 利用resend发邮件，用户登录功能，开发完成</li>
    <li><strong>2025-08-28</strong>：Version 0.21 增加用户登录功能，开发中</li>
    <li><strong>2025-08-28</strong>：Version 0.1 游戏成绩用浏览器本地存储</li>
  </ul>
</details>
</body>
</html>
